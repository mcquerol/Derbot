
#include "mcc_generated_files/mcc.h"
#define I2C_freq 100000 

#define unlit 0x3e
#define lit 0x38 
#define zero 0x3f 
#define one 0x6 
#define two 0x5b 
#define three 0x4f 
#define four 0x66 
#define five 0x6d 
#define six 0x7d 
#define seven 0x7 
#define eight 0x7f 
#define nine 0x67 

unsigned char digits[] = {zero, one, two, three, four, five, six, seven, eight, nine, unlit, lit};

#define mcp23008_address_write 0x40 //important changed based on a1,a0,a2
#define mcp23008_address_read 0x41 //important changed based on a1,a0,a2
#define MCP_IODIR 0x00//important 
#define MCP_GPIO 0x09//important 
#define MCP_IPOL 0x01 
#define MCP_GPINTEN 0x02 
#define MCP_DEFVAL 0x03 
#define MCP_INTCON 0x04 
#define MCP_IOCON 0x05 
#define MCP_GPPU 0x06 
#define MCP_INTF 0x07 
#define MCP_INTCAP 0x08 
#define MCP_OLAT 0x0A 

//Declairng and intialising funtions

void diagnostic(void);
void motor_fwd(unsigned char dir, unsigned char spd, bool STAT);
void movement(void);
void rightPosition(void);
void leftPosition(void);
void PIC_Initialise(void); //Pic
void I2C_Initialise(void); //i2c
void MCP23008_Initialise(void); //mcp
void IdleI2C(void); //Idlei2c
void StartI2C(void); //start i2c
void I2C_send_data(unsigned char device_address, unsigned char register_address, unsigned char register_data); //i2c send data requires 3 unsigned char 
void WriteI2C(unsigned char data); //writei2c requires unsigned char
void StopI2C(void); //stopi2c
void I2C(void);
void adcFunction(void);

int adcResult, intialResult, time1;
int UnLit = 0;
int Lit = 0;
int LDRVAL = 60;
unsigned long time;
int debounceTime = 50;
int positionHolder = 0;

bool IsOptoL(void);
bool IsOptoR(void);
bool IsOptoFarR(void);
bool IsBumperL(void);
bool IsBumperR(void);

void main(void)
{

    SYSTEM_Initialize(); // Initialize the device - generated by MCC 
    I2C_Initialise();
    MCP23008_Initialise();
    diagnostic();
    //    adcFunction();
    while (1) // Loop for ever
    {
        //diagnostic();
        motor_fwd('L', 255, HIGH);
        motor_fwd('R', 250, HIGH);
        //initial motor conditions
        adcFunction(); //calling the ADC function to detect if there is light in front 

        //if its dark do this......
        if (adcResult > LDRVAL)
        {
            if (IsOptoR())
            { // 0 for opto-coupler is dark and 1 is light
                motor_fwd('L', 250, HIGH);
                motor_fwd('R', 105, HIGH);
                continue;
            }
            else if (IsOptoL())
            { // 0 for opto-coupler is dark and 1 is light
                motor_fwd('L', 105, HIGH);
                motor_fwd('R', 250, HIGH);
                continue;
            }
                //            else if (BUMPER_LEFT_GetValue() == 0 && BUMPER_RIGHT_GetValue() == 0)
            else if (OPTO_FAR_RIGHT_GetValue() == 0)
            {
                LED_LEFT_SetHigh();
                LED_RIGHT_SetHigh();
                __delay_ms(450);
                motor_fwd('L', 255, LOW);
                motor_fwd('R', 255, LOW);
                while (1)
                {
                    __delay_ms(100);
                    I2C();
                }
            }

            leftPosition();



            if (IsBumperR())
            {
                //              
                LED_LEFT_SetHigh(); //if it is LOW then the back right LED is turned on
                UnLit++; //un-lit variable is increased by 1
                __delay_ms(1000); // the code is paused by 2 seconds
                //                
                LED_LEFT_SetLow(); //before the back right LED is turned off again
            }
        }



        if (adcResult < LDRVAL)
        {
            motor_fwd('L', 255, HIGH);
            motor_fwd('R', 250, HIGH);
            //initial motor conditions
            adcFunction();
            positionHolder = 1;

            while (positionHolder == 1)
            {
                motor_fwd('L', 255, HIGH);
                motor_fwd('R', 250, HIGH);

                if (IsOptoR())
                { // 0 for opto-coupler is dark and 1 is light
                    motor_fwd('L', 250, HIGH);
                    motor_fwd('R', 105, HIGH);
                    continue;
                }

                else if (IsOptoL())
                { // 0 for opto-coupler is dark and 1 is light
                    motor_fwd('L', 105, HIGH);
                    motor_fwd('R', 250, HIGH);
                    continue;
                }

                else if (OPTO_FAR_RIGHT_GetValue() == 0)
                {
                    LED_LEFT_SetHigh();
                    LED_RIGHT_SetHigh();
                    __delay_ms(450);
                    motor_fwd('L', 255, LOW);
                    motor_fwd('R', 255, LOW);
                    while (1)
                    {
                        __delay_ms(100);
                        I2C();
                    }
                }


                rightPosition();

                if (IsBumperL())
                {

                    LED_RIGHT_SetHigh(); //if it is LOW then the back right LED is turned on
                    Lit++; //un-lit variable is increased by 1
                    __delay_ms(1000); // the code is paused by 2 seconds
                    LED_RIGHT_SetLow(); //before the back right LED is turned off again
                    positionHolder = 0;
                }
                continue;
            }
        }

    }
}

void diagnostic(void) // Toggles leds for 0.3s each (Tcy = 1us)
{

    LED_LEFT_Toggle(); // PORTCbits.RC5 = 0
    LED_RIGHT_Toggle(); // PORTCbits.RC6 = 1
    __delay_ms(300); // 0.3 second delay
    LED_LEFT_Toggle(); // PORTCbits.RC5 = 1
    LED_RIGHT_Toggle(); // PORTCbits.RC6 = 0
}

void motor_fwd(unsigned char dir, unsigned char spd, bool STAT)
{
    if (dir == 'L')
    {
        CCPR2L = spd; //left motor speed
        LEFT_MTR_EN_PORT = STAT; // HIGH or LOW for left motor
    }
    else
    {

        CCPR1L = spd; // right motor speed
        RIGHT_MTR_EN_PORT = STAT; // HIGH or LOW for right motor
    }
}

void I2C_Initialise()
{

    SSP1STAT = 0x00;
    SSP1CON1 = 0x28;
    SSP1CON2 = 0x00;
    SSP1CON3 = 0x08;
    SSP1ADD = 0x09;
}

void MCP23008_Initialise(void)
{

    I2C_send_data(mcp23008_address_write, MCP_IODIR, 0x00);
    IdleI2C();
    I2C_send_data(mcp23008_address_write, MCP_IPOL, 0x00);
    IdleI2C();
    I2C_send_data(mcp23008_address_write, MCP_GPINTEN, 0x00);
    IdleI2C();
    I2C_send_data(mcp23008_address_write, MCP_IOCON, 0x3E);
    IdleI2C();
    I2C_send_data(mcp23008_address_write, MCP_GPPU, 0x00);
}

void I2C_send_data(unsigned char device_address, unsigned char register_address, unsigned char register_data)
{

    StartI2C();
    WriteI2C(device_address);
    IdleI2C();
    WriteI2C(register_address);
    IdleI2C();
    WriteI2C(register_data);
    IdleI2C();
    StopI2C();
}

void IdleI2C(void)
{

    while ((SSP1CON2 & 0x1F) || (SSP1STAT & 0x02));
}

void StartI2C(void)
{
    PIR1bits.SSPIF = 0;
    SSP1CON2bits.SEN = 1;

    while ((SSP1STAT & 0x04) || (SSP1CON2 & 0x1F));
    //    while (!PIR1bits.SSPIF);
    PIR1bits.SSPIF = 0;
}

void WriteI2C(unsigned char data)
{
    SSP1BUF = data;

    while (SSP1STATbits.BF);
}

void StopI2C()
{

    SSP1CON2bits.PEN = 1;
}

void I2C(void)
{

    //    for(int x=0; x<12; x++)
    {

        I2C_send_data(mcp23008_address_write, MCP_GPIO, digits[10]); // U
        __delay_ms(1000);
        I2C_send_data(mcp23008_address_write, MCP_GPIO, digits[UnLit]);
        __delay_ms(1000);
        I2C_send_data(mcp23008_address_write, MCP_GPIO, digits[11]); // L
        __delay_ms(1000);
        I2C_send_data(mcp23008_address_write, MCP_GPIO, digits[Lit]);
        __delay_ms(1000);
    }

}

//Servo position to the right

void rightPosition(void)//naming the function
{
    //        unsigned int i; //declaring an unsigned integer called 'i'
    //        for (i = 0; i < 50; i++)//starting a for loop, intialising 'i' to 0 and incrementing it by 1 upto 50

    SERVO_PWM_PORT = HIGH;
    __delay_us(2050);
    SERVO_PWM_PORT = LOW;
    __delay_us(19250);
    adcFunction();

}

//Servo position to the left

void leftPosition(void) //180 Degree
{
    //    unsigned int i;
    //    for (i = 0; i < 50; i++)
    {

        SERVO_PWM_PORT = HIGH;
        __delay_us(2350);
        SERVO_PWM_PORT = LOW;
        __delay_us(19250);
        adcFunction();

    }

}


//Analoge to Digital Conversion (ADC) function

void adcFunction(void)
{
    __delay_us(7); //delaying the code by 7us to slow it down
    ADCON0bits.GO = 1; //setting the 'ADC begin' bit to HIGH
    while (ADCON0bits.GO == 1)//pausing the code while the ADC conversion is taking place
    {
    }

    adcResult = ADRESH;

}

bool IsBumperL(void) // return true when right op is dark (dark = 0, light = 1)
{

    return (BUMPER_LEFT_GetValue() == 0);
}

bool IsBumperR(void)
{

    return (BUMPER_RIGHT_GetValue() == 0);
}

bool IsOptoL(void) // return true when left opto is dark (dark = 0, light = 1)
{

    return (OPTO_LEFT_GetValue() == 0);
}

bool IsOptoR(void) // return true when right opto is dark (dark = 0, light = 1)
{

    return (OPTO_RIGHT_GetValue() == 0);
}

bool IsOptoFarR(void)
{
    return (OPTO_FAR_RIGHT_GetValue() == 0);
}
